# AUTH

Алгоритм авторизации по JWT с использованием access и refresh токенов, включая хранение и отправку токенов.

### Шаг 1: Аутентификация пользователя

1. **Пользователь отправляет свои учетные данные (логин и пароль) на сервер.**
    - **Отправка**: Учетные данные отправляются через POST-запрос на сервер (например, на `/login`).

### Шаг 2: Проверка учетных данных и создание токенов

2. **Сервер проверяет учетные данные:**
    - Если учетные данные неверные, сервер возвращает ошибку аутентификации.
    - Если учетные данные верные, сервер генерирует access и refresh токены.

3. **Генерация токенов:**
    - **Access токен** создается с коротким временем жизни (например, 15 минут).
    - **Refresh токен** создается с более длительным временем жизни (например, 7 дней).

4. **Сервер возвращает access и refresh токены клиенту.**
    - **Access токен**: возвращается в теле ответа JSON.
    - **Refresh токен**: устанавливается в HttpOnly cookie.

### Шаг 3: Хранение токенов на клиенте

5. **Хранение токенов на клиенте:**
    - **Access токен**: Хранится в памяти клиента (например, в переменной JavaScript) или в локальном хранилище браузера (localStorage/sessionStorage).
    - **Refresh токен**: Хранится в более безопасном месте, недоступном для JavaScript, например, в HttpOnly cookies, чтобы минимизировать риск XSS атак.

### Шаг 4: Авторизация с использованием Access токена

6. **Клиент отправляет access токен при каждом запросе к защищенному ресурсу:**
    - **Отправка**: Access токен включается в заголовок Authorization при каждом запросе (например, `Authorization: Bearer <access_token>`).

7. **Сервер проверяет access токен:**
    - Если токен валиден и не истек, сервер обрабатывает запрос.
    - Если токен недействителен или истек, сервер возвращает ошибку 401 Unauthorized.

### Шаг 5: Обновление Access токена с использованием Refresh токена

8. **Если access токен истек, клиент отправляет запрос на обновление токена, включая refresh токен.**
    - **Отправка**: Refresh токен отправляется через GET-запрос на сервер (например, на `/refresh`).

9. **Сервер проверяет refresh токен:**
    - Если refresh токен валиден и не истек, сервер генерирует новый access токен и возвращает его клиенту в ответе JSON.
    - Если refresh токен недействителен или истек, сервер возвращает ошибку 401 Unauthorized, и клиент должен выполнить повторную аутентификацию.

### Шаг 6: Повторное использование новых токенов

10. **Клиент получает новый access токен и сохраняет его.**
    - **Хранение**: Новый access токен сохраняется так же, как и первоначальный (например, в памяти или localStorage).

### Примерный поток данных:

1. **Аутентификация:**
    - Клиент -> Сервер: POST `/login` с логином и паролем
    - Сервер -> Клиент: JSON с access токеном, HttpOnly cookie с refresh токеном

2. **Запрос к защищенному ресурсу:**
    - Клиент -> Сервер: GET/POST запрос с заголовком `Authorization: Bearer <access_token>`
    - Сервер -> Клиент: Данные ресурса или ошибка 401

3. **Обновление токена:**
    - Клиент -> Сервер: GET `/refresh` с автоматическим включением refresh токена из HttpOnly cookie
    - Сервер -> Клиент: Новый access токен в JSON

# LOGOUT

### Шаг 1: Инициирование logout

1. **Пользователь инициирует logout:**
    - **Отправка**: Клиент отправляет запрос на сервер для выполнения logout (например, через GET-запрос на `/logout`).

### Шаг 2: Проверка и удаление токенов на сервере

2. **Сервер проверяет наличие токенов:**
    - **Access токен**: Проверяется, если он отправлен в заголовке Authorization (например, `Authorization: Bearer <access_token>`).
    - **Refresh токен**: Проверяется, если он отправлен в HttpOnly cookie.

3. **Сервер выполняет действия по удалению токенов:**
    - **Access токен**: Может быть просто проигнорирован (JWT не требует явного удаления на сервере, так как они статичны и проверяются на клиенте).
    - **Refresh токен**: Удаляется из базы данных или списка валидных токенов, если такие используются для дополнительной безопасности.

### Шаг 3: Удаление токенов на клиенте

4. **Сервер отправляет ответ клиенту:**
    - Ответ подтверждает успешный logout (например, статус 200 OK).
    - Ответ содержит команду на удаление HttpOnly cookie с refresh токеном путем установки истекшего срока действия.

5. **Клиент обрабатывает ответ:**
    - **Access токен**: Удаляется из памяти клиента или из localStorage/sessionStorage.
    - **Refresh токен**: Сервер отправляет клиенту Set-Cookie заголовок с истекшим сроком действия.

### Примерный поток данных:

1. **Инициирование logout:**
    - Клиент -> Сервер: GET `/logout` с заголовком `Authorization: Bearer <access_token>`

2. **Проверка и удаление токенов на сервере:**
    - Сервер проверяет токены и удаляет refresh токен из базы данных или списка валидных токенов (если используется).

3. **Ответ сервера:**
    - Сервер -> Клиент: Подтверждение успешного logout и заголовок Set-Cookie с истекшим сроком действия для refresh токена.

4. **Удаление токенов на клиенте:**
    - Клиент удаляет access токен из localStorage/sessionStorage.
    - Браузер удаляет HttpOnly cookie с refresh токеном, получив команду от сервера.

### Пример алгоритма:

1. **Инициирование logout:**
    - Клиент отправляет запрос на `/logout`.

2. **Серверный обработчик logout:**
    - Проверяет наличие access и refresh токенов.
    - Удаляет refresh токен из базы данных или списка валидных токенов.
    - Отправляет клиенту Set-Cookie заголовок с истекшим сроком действия для refresh токена.

3. **Клиент обрабатывает ответ:**
    - Удаляет access токен из localStorage/sessionStorage.
    - Браузер автоматически удаляет HttpOnly cookie с refresh токеном по команде сервера.

### Пример HTTP-ответа сервера:

```http
HTTP/1.1 200 OK
Set-Cookie: refresh_token=; HttpOnly; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT
Content-Type: application/json

{
    "message": "Logout successful"
}
```
